#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np
import itertools

#%% Functions for permutation matrices

def perm_parity(input_list):
    """
    Determines the parity of the permutation required to sort the list.
    Outputs 0 (even) or 1 (odd).
    """
    
    parity = 0
    for i, j in itertools.combinations(range(len(input_list)), 2):
        if input_list[i] > input_list[j]:
            parity += 1
    
    return parity % 2

def rand_sym_mat(N):
    """
    Generates a random N x N permutation matrix.
    """
    Q = np.eye(N, dtype='int')
    
    p = np.random.permutation(np.arange(N))
    
    return Q[:,p]

def rand_alt_mat(N):
    """
    Generates a random N x N permutation matrix of determinant +1.
    """
    
    Q = np.eye(N, dtype='int')
    
    s = 1
    while s > 0:
        p = np.random.permutation(np.arange(N))
        s = perm_parity(p)
    
    return Q[:,p]

def rand_sym_perm(N):
    """
    Generates a random N-permutation (as a tuple). Permutations in this form
    can be thought of as maps p : {0, ..., N-1} -> {0, ..., N-1}, i -> p[i],
    where p[i] is the i-th element of the tuple p.
    """
    
    return tuple(np.random.permutation(np.arange(N)))

def rand_alt_perm(N):
    """
    Generates a random N-permutation of even parity.
    """
    
    s = 1
    while s > 0:
        p = np.random.permutation(np.arange(N))
        s = perm_parity(p)
    
    return tuple(p)

#%% Functions for measurement counts
    
def tally_nonzero_subdets(obs_dict, diag_terms, Q):
    """
    Tallies which observables in obs_dict are measured by a given Majorana swap
    circuit (generated by Q). "Measurable" is defined by diag_terms. Updates
    obs_dict in-place and returns nothing.
    
    !!! THIS FUNCTION CURRENTLY DEPRECATED !!!

    Parameters
    ----------
    obs_dict : dict
        Dictionary of observables we wish to measure. Formatted as
        {indices : number of times tallied}. Note that the indices must be
        sorted in ascending order.
        The goal is to run this function many times until all tallies are at
        least r, where r is a user-determined hyperparameter.
    diag_terms : iterable
        List of indices corresponding to the diagonal Majorana operators (with
        respect to the computational basis). While the qubit encoding does not
        affect the number of measurements, it does matter when determining (in
        experiment) which specific string of Pauli-Z's correspond to which of
        these Majorana operators.
    Q : numpy.ndarray
        A 2n x 2n permutation matrix.

    Returns
    -------
    None.

    """
    
    # we keep track of which terms have already been accounted for, to avoid
    # potential double-counting
    marked_terms = []
    
    for mu in diag_terms:
        
        K = len(mu)
        
        for nu in obs_dict:
            
            if len(nu) != K or nu in marked_terms:
                continue
            
            # the following is a hack that determines whether a subdeterminant
            # is nonzero (but if it is nonzero, it doesn't actually determine
            # whether it is +1 or -1). The reasoning is again for speed, since
            # this code is just interested in counting measurements...
            submat_sum = 0
            for p in mu:
                for q in nu:
                    if Q[p,q] == 1:
                        submat_sum += 1
                        break
            
            if submat_sum == K:
                obs_dict[nu] += 1
                marked_terms.append(nu)
                break
    
    return

def permute_majorana(indices, Q):
    """
    Permutes indices according to the permutation Q. Rather than returning the
    resulting indices as-is, it returns them sorted along with the sign of the
    permutation which was required to do so (NOT the sign of Q).

    Parameters
    ----------
    indices : iterable of int
        Input (Majorana operator) indices; length-2k indices correspond to a
        k-RDM operator.
    Q : iterable of int
        Length-2n permutation.

    Returns
    -------
    tuple
        The image of the permutation, sorted.
    sign : int
        The sign required to sort the permuted indices.

    """
    
    l = [Q[i] for i in indices]
    sign = (-1)**perm_parity(l)
    l.sort()
    
    return tuple(l), sign

def invert_permutation(permutation):
    """
    Given input permutation Q, returns Q^{-1}.

    Parameters
    ----------
    permutation : iterable
        A permutation as an iterable.

    Returns
    -------
    tuple
        The inverse permutation.

    """
    
    return tuple(np.arange(len(permutation))[np.argsort(permutation)])

def tally_majorana_matches(ops_dict, Q, k_max=None):
    """
    Given a 2n x 2n permutation Q, mark which elements of obs_dict can be
    measured (diagonalized) by the fermionic Gaussian circuit U(Q).

    Parameters
    ----------
    ops_dict : dict
        Dictionary of Majorana operators which we wish to measure. {key : val}
        pattern should be {(Majorana indices) : number of times accounted for}.
    Q : iterable of int
        Permutation as a 2n-length tuple.
    k_max : int, optional
        The maximum Majorana degree in obs_dict to check for. If None, the
        maximum degree is automatically determined. It is preferrable to set
        this for speed.

    Returns
    -------
    list
        List of operators measured, as a tuple in the form (Majorana, diagonal
        Majorana, sign), where sign is the associated sign accrued by the
        unitary action. That is,
        
        U(Q) (Majorana) U(Q)^\dagger = sign * (diagonal Majorana).

    """
    
    if k_max is None:
        k_max = max([len(term) for term in ops_dict])
    
    n = len(Q) // 2
    
    measured_ops = []
    
    for j in range(1, k_max+1):
        for P in itertools.combinations(range(n), j):
            diag_index = [2*p+i for p in P for i in range(2)]
            
            Q_inv = invert_permutation(Q)
            permuted_diag_index, sign = permute_majorana(diag_index, Q_inv)
        
            if permuted_diag_index in ops_dict:
                ops_dict[permuted_diag_index] += 1
                measured_ops.append((permuted_diag_index, tuple(diag_index),
                                     sign))
    
    return measured_ops

def construct_random_measurements_FGU(ops_dict, n, k_max=None, r=10):
    """
    Constructs a random cover of ops_dict using the hyperparameter r. That is,
    it generates random 2n-permutations until all Majorana operators in
    ops_dict have been accounted for at least r times.

    Parameters
    ----------
    ops_dict : dict
        Dictionary of Majorana operators which we wish to measure. {key : val}
        pattern should be {(Majorana indices) : number of times accounted for}.
    n : int
        Number of fermionic orbitals.
    k_max : int, optional
        The maximum Majorana degree in obs_dict to check for. If None, the
        maximum degree is automatically determined. It is preferrable to set
        this for speed.
    r : int, optional
        The minimum number of times each operator must be covered until the
        function halts. The default is 10.

    Returns
    -------
    random_measurements : dict
        The resulting cover of Majorana operators. The dictionary pattern is
        {permutation : [(measured_op_indices, sign)]}.

    """
    
    random_measurements = {}
    
    while any(counts < r for counts in ops_dict.values()):
        Q = rand_sym_perm(2*n)
        if Q in random_measurements:
            continue
        
        measured_ops = tally_majorana_matches(ops_dict, Q,
                                                     k_max=k_max)
        
        if len(measured_ops) > 0:
            random_measurements[Q] = measured_ops
    
    return random_measurements

#%% Example

if __name__ = '__main__':

    n = 6
    k = 2

    majorana_k_rdm_counts = {}

    for j in range(1, k+1):
        for mu in itertools.combinations(range(2*n), 2*j):
            majorana_k_rdm_counts[mu] = 0

    rand_meas = construct_random_measurements_FGU(majorana_k_rdm_counts, n,
                                                  k_max=k, r=50
