from typing import cast, Iterable, Sequence, Tuple
from itertools import combinations

import numpy as np
import cirq

from openfermion.linalg import givens_rotate


def optimal_gaussian_circuit(qubits: Sequence[cirq.Qid],
                             orthogonal_matrix: np.ndarray
                             ) -> Iterable[cirq.Operation]:
    # Compute the decomposition of the orthogonal matrix into 4 x 4 orthogonal block transformations, a diagonal matrix
    # of signs, and one extra Givens rotation in left_rotations
    left_rotations, right_rotations, signs = majorana_block_decomposition(orthogonal_matrix)

    # Decompose each 4 x 4 transformation into a two-qubit circuit of Givens rotations and a layer of Pauli gates
    for op in left_rotations[:-1]:
        p, q, orth_mat = cast(Tuple[int, int, np.ndarray], op)
        yield standard_majorana_givens_circuit(qubits, orth_mat, p)

    # The extra Givens rotation from left_rotations
    p, q, theta = cast(Tuple[int, int, float], left_rotations[-1])
    yield cirq.Z(qubits[p // 2])**(theta / np.pi)

    # Implement the diagonal matrix of signs
    yield majorana_sign_gates(qubits, signs)

    # Same as with left_rotations
    for op in reversed(right_rotations):
        p, q, orth_mat = cast(Tuple[int, int, np.ndarray], op)
        yield standard_majorana_givens_circuit(qubits, orth_mat, p)


def optimal_gaussian_circuit_spin_block_diag(up_qubits: Sequence[cirq.Qid],
                                             down_qubits: Sequence[cirq.Qid],
                                             up_orthogonal_matrix: np.ndarray,
                                             down_orthogonal_matrix: np.ndarray,
                                             up_matrix_det=None,
                                             ) -> Iterable[cirq.Operation]:
    # Construct independent Gaussian circuits on each spin sector independently
    yield optimal_gaussian_circuit(up_qubits, up_orthogonal_matrix)
    yield optimal_gaussian_circuit(down_qubits, down_orthogonal_matrix)

    """
    If det(Q_up) == -1, then we need to correct signs on the Majoranas on the spin-down chain. This convention is
    chosen such that this circuit is equivalent to the circuit generated by the block-diagonal matrix
    [Q_up, 0]
    [0, Q_down],
    up to a global phase factor of course. Alternatively we could just say that Q_down = -Q_down if det(Q_up) == -1,
    but then Q_up and Q_down are no longer independent variables.
    
    The user is given the option to enter the determinant of Q_up from a precalculation, to avoid having to compute
    the determinant here. This is useful when, for instance, Q_up is a permutation matrix, in which case it takes O(n^2)
    integer operations to calculate its determinant, as opposed to O(n^3) floating point operations in general.
    """
    if up_matrix_det is None:
        up_matrix_det = np.linalg.det(up_orthogonal_matrix)
    if up_matrix_det < 0.0:
        for qubit in down_qubits:
            yield cirq.Z(qubit)


def majorana_block_decomposition(orthogonal_matrix: np.ndarray
                                 ) -> Tuple[list, list, np.ndarray]:
    N = orthogonal_matrix.shape[0]
    if N % 2 == 1:
        raise ValueError('Input must be an orthogonal matrix with even dimension.')
    n_modes = N // 2

    current_matrix = np.copy(orthogonal_matrix)

    right_rotations = []
    left_rotations = []
    for i in range(1, n_modes):
        if i % 2 == 1:
            for j in range(i):
                # The beginning row and column indices to extract the 2 x 4 matrix A
                row = 2 * (n_modes - j - 1)
                col = 2 * (i - j - 1)
                A = current_matrix[row:row + 2, col:col + 4]
                # QR decompose A such that we zero its left 2 x 2 block
                Q = block_qr_decomposition(A)
                # Perform the orthogonal transformation to zero out that block
                block_ortho_transform(current_matrix, Q.T, col, col + 2, which='col')
                # gmat = np.eye(N)
                # gmat[col:col + 4, col:col + 4] = Q.T
                # current_matrix = current_matrix @ gmat

                right_rotations.append((col, col + 2, Q))

        else:
            for j in range(1, i + 1):
                row = 2 * (n_modes + j - i - 2)
                col = 2 * (j - 1)
                A = current_matrix[row:row + 4, col:col + 2]
                Q = block_qr_decomposition(A)
                block_ortho_transform(current_matrix, Q.T, row, row + 2, which='row')
                # gmat = np.eye(N)
                # gmat[row:row + 4, row:row + 4] = Q.T
                # current_matrix = gmat @ current_matrix

                left_rotations.append((row, row + 2, Q))

    """
    Givens-rotate the remaining 2 x 2 block on the diagonal. If n_modes is odd, then this block is at the bottom
    because the last step of the above loop zeroes out chunks of size 4 x 2. In other words, the nonzero
    upper-triangular 2 x 2 block is pushed to the top, ensuring that all the 2 x 2 blocks along the diagonal are
    truly diagonal, except for the lowermost 2 x 2 block which was untouched by that last loop (nothing was pushed
    into it). On the other hand, if n_modes is even, then the last step zeroes out 4 x 2 chunks, so now the
    uppermost 2 x 2 block was left untouched which needs to be Givens-rotated.
    """
    if n_modes % 2 == 1:
        i = N - 2
    else:
        i = 0

    A = current_matrix[i:i + 2, i:i + 2]
    theta = np.arctan2(-A[1, 0], A[0, 0])
    gmat = real_givens_matrix(theta)
    givens_rotate(current_matrix, gmat.T, i, i + 1, which='row')

    left_rotations.append((i, i + 1, theta))

    """
    The above decomposition gives orthogonal_matrix = L_1 ... L_a D R_b ... R_1, where D = current_matrix is a
    diagonal matrix of signs and L_i, R_j are from left_rotations and right_rotations (in the order of the lists),
    each corresponding to an orthogonal transformation in a 4-dimensional subspace.

    Now we wish to rearrange this decomposition so that the diagonal matrix appears at the right. We do this by
    finding a new 4 x 4 orthogonal transformation R' such that D R = R' D' for a new diagonal matrix D'. This is
    achieved by the usual QR decomposition. Then iterate this over right_rotations until D' is pushed to the end.
    
    For now this is commented out because it doesn't seem to be worth doing. We will need to insert layers of sign
    gates (Pauli gates) per 4 x 4 block anyway, so whether we do this in the middle or push it to the end doesn't affect
    the depth, so it seems to just be unnecessary classical compute.
    """
    # new_right_rotations = []
    # for op in reversed(right_rotations):
    #     p, q, R = op
    #     indices = range(p, q + 1)
    #     d = [current_matrix[i, i] for i in indices]
    #     for j in range(len(indices)):
    #         R[j, :] *= d[j]
    #         current_matrix[indices[j], indices[j]] = 1.0
    #
    #     new_right_rotations.append((p, q, R))
    #
    # rotations = left_rotations + new_right_rotations
    #
    # return rotations, np.diag(current_matrix)

    return left_rotations, right_rotations, np.diag(current_matrix)


def block_qr_decomposition(block_matrix: np.ndarray) -> np.ndarray:
    if block_matrix.shape == (4, 2):
        Q, _ = np.linalg.qr(block_matrix, mode='complete')

    elif block_matrix.shape == (2, 4):
        Q, _ = np.linalg.qr(block_matrix.T, mode='complete')
        Q = Q.T[[2, 3, 0, 1], :]

    else:
        raise ValueError('Input must be a 2 x 4 or 4 x 2 matrix.')

    return Q


def block_ortho_transform(operator: np.ndarray,
                          orthogonal_matrix: np.ndarray,
                          p: int,
                          q: int,
                          which='row'):

    if orthogonal_matrix.shape != (4, 4):
        raise ValueError('"orthogonal_matrix" must be 4 x 4.')

    if which == 'row':
        # Rotate rows p, p + 1, q, q + 1
        # Effects left multiplication by orthogonal_matrix
        rows_p = operator[p:p + 2].copy()
        rows_q = operator[q:q + 2].copy()
        rows = np.vstack((rows_p, rows_q))

        transformed_rows = orthogonal_matrix.dot(rows)
        operator[p:p + 2] = transformed_rows[0:2]
        operator[q:q + 2] = transformed_rows[2:4]

    elif which == 'col':
        # Rotate columns p, p + 1, q, q + 1
        # Effects right multiplication by orthogonal_matrix
        cols_p = operator[:, p:p + 2].copy()
        cols_q = operator[:, q:q + 2].copy()
        cols = np.hstack((cols_p, cols_q))

        transformed_cols = cols.dot(orthogonal_matrix)
        operator[:, p:p + 2] = transformed_cols[:, 0:2]
        operator[:, q:q + 2] = transformed_cols[:, 2:4]

    else:
        raise ValueError('"which" must be equal to "row" or "col".')

    return


def real_givens_matrix(theta: float) -> np.ndarray:

    # Note that this rotates clockwise by theta in the (i, j) axes, following the convention that the corresponding
    # rotation by Pauli operator P of an observable A is:
    # exp(-i (theta / 2) P) A exp(i (theta / 2) P)
    c = np.cos(theta)
    s = np.sin(theta)
    gmat = np.array([[c, s],
                     [-s, c]])

    return gmat


def standard_givens_decomposition(orthogonal_matrix: np.ndarray
                                  ) -> Tuple[list, np.ndarray]:
    N = orthogonal_matrix.shape[0]

    current_matrix = np.copy(orthogonal_matrix)

    rotations = []
    for j in range(N - 1):
        for i in range(N - 1, j, -1):
            theta = np.arctan2(-current_matrix[i, j], current_matrix[i - 1, j])
            gmat = real_givens_matrix(theta)
            givens_rotate(current_matrix, gmat.T, i - 1, i, which='row')

            rotations.append((i - 1, i, theta))

    return rotations, np.diag(current_matrix)


def standard_majorana_givens_circuit(qubits: Sequence[cirq.Qid],
                                     orthogonal_matrix: np.ndarray,
                                     index_offset: int=0
                                     ) -> Iterable[cirq.Operation]:
    rotations, signs = standard_givens_decomposition(orthogonal_matrix)

    for op in rotations:
        r, s, theta = cast(Tuple[int, int, float], op)
        yield majorana_rotation_gate(qubits, r + index_offset, s + index_offset, theta)

    full_sign_diag = np.ones(2 * len(qubits))
    full_sign_diag[index_offset:index_offset + 4] = signs
    yield majorana_sign_gates(qubits, full_sign_diag)


def majorana_rotation_gate(qubits: Sequence[cirq.Qid],
                           p: int, q: int,
                           theta: float
                           ) -> Iterable[cirq.Operation]:
    if np.isclose(theta, 0.0):
        return

    if p > q:
        p, q = q, p
    d = q - p

    if d == 1:
        if p % 2 == 0:
            i = p // 2
            yield cirq.Z(qubits[i])**(theta / np.pi)
        else:
            i = (p - 1) // 2
            yield cirq.XXPowGate(exponent=theta / np.pi).on(qubits[i], qubits[i + 1])

    elif d == 2:
        if p % 2 == 0:
            i = p // 2
            yield cirq.Z(qubits[i])**(-0.5)
            yield cirq.XXPowGate(exponent=-theta / np.pi).on(qubits[i], qubits[i + 1])
            yield cirq.Z(qubits[i])**0.5
        else:
            i = (p - 1) // 2
            yield cirq.Z(qubits[i + 1])**(-0.5)
            yield cirq.XXPowGate(exponent=theta / np.pi).on(qubits[i], qubits[i + 1])
            yield cirq.Z(qubits[i + 1])**0.5

    elif d == 3 and p % 2 == 0:
        i = p // 2
        yield cirq.YYPowGate(exponent=-theta / np.pi).on(qubits[i], qubits[i + 1])

    else:
        raise ValueError('Majorana indices do not map onto 2-local gates.')


def majorana_sign_gates(qubits: Sequence[cirq.Qid],
                        signs: Iterable
                        ) -> Iterable[cirq.Operation]:
    # if isinstance(signs, np.ndarray):
    #     if len(signs.shape) == 2:
    #         signs = np.diag(signs)
    signs = np.sign(signs)

    N = len(signs)
    n_modes = N // 2

    pauli_tableau = np.zeros(N, dtype=int)
    for p in range(n_modes):
        if signs[2 * p] == signs[2 * p + 1]:
            if signs[2 * p] == -1.0:
                pauli_tableau[p + n_modes] += 1
        else:
            pauli_tableau[p] += 1
            if signs[2 * p] == 1.0:
                for q in range(p + 1, n_modes):
                    pauli_tableau[q + n_modes] += 1
            else:
                for q in range(p, n_modes):
                    pauli_tableau[q + n_modes] += 1

    pauli_tableau %= 2

    for p in range(n_modes):
        pauli = (pauli_tableau[p], pauli_tableau[p + n_modes])
        if pauli == (0, 1):
            yield cirq.Z(qubits[p])
        elif pauli == (1, 0):
            yield cirq.X(qubits[p])
        elif pauli == (1, 1):
            yield cirq.Y(qubits[p])


def embed_unitary_into_orthogonal_matrix(unitary: np.ndarray
                                         ) -> np.ndarray:

    # We take the convention that
    # optimal_givens_decomposition(qubits, unitary) = optimal_gaussian_circuit(qubits, orthogonal_matrix)
    # (up to a global phase factor).
    n_orbitals = unitary.shape[0]

    orthogonal_matrix = np.zeros((2 * n_orbitals, 2 * n_orbitals))

    for p in range(n_orbitals):
        real_part = unitary[p, p].real
        imag_part = unitary[p, p].imag
        orthogonal_matrix[2 * p:2 * p + 2, 2 * p:2 * p + 2] = np.array(
            [[real_part, imag_part],
             [-imag_part, real_part]]
        )

    for p, q in combinations(range(n_orbitals), 2):
        real_part = unitary[q, p].real
        imag_part = unitary[q, p].imag
        orthogonal_matrix[2 * p:2 * p + 2, 2 * q:2 * q + 2] = np.array(
            [[real_part, imag_part],
             [-imag_part, real_part]]
        )

        real_part = unitary[p, q].real
        imag_part = unitary[p, q].imag
        orthogonal_matrix[2 * q:2 * q + 2, 2 * p:2 * p + 2] = np.array(
            [[real_part, imag_part],
             [-imag_part, real_part]]
        )

    return orthogonal_matrix

