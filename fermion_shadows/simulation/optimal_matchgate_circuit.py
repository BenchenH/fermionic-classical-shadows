"""
The code here allows for compiling n-qubit circuits of generalized matchgates (aka,
fermionic Gaussian unitaries), using their 2n x 2n orthogonal matrix representation.
We use Cirq to write the quantum circuit, although the overall decomposition
algorithm is universally applicable.

We assume the Jordan-Wigner mapping: for p \in {0, ..., n-1}, define the Majorana
operators from the creation and annihilation operators a_p, a_p^\dagger as

\gamma_{2p} = a_p + a_p^\dagger = X_p \prod_{q < p} Z_q,
\gamma_{2p+1} = -i(a_p - a_p^\dagger) = Y_p \prod_{q < p} Z_q.

The Gaussian unitary U, produced from the input orthogonal matrix Q, implements the
adjoint transformation

U^\dagger \gamma_i U = \sum_j Q_{ij} \gamma_j.

If det(Q) = 1 then U preserves parity (corresponding to proper matchgates or FGUs),
otherwise if det(Q) = -1 then U flips the parity of its input state.

The algorithm for this protocol is described in arXiv:[],
and the base matrix decomposition scheme is built off of arXiv:1603.08788.
"""
from typing import cast, Iterable, Sequence, Tuple
from itertools import combinations

import numpy as np
import cirq

from openfermion.linalg import givens_rotate


def optimal_gaussian_circuit(qubits: Sequence[cirq.Qid],
                             orthogonal_matrix: np.ndarray
                             ) -> Iterable[cirq.Operation]:
    """
    Constructs a Cirq circuit which implements the fermionic Gaussian
    unitary transformation given by the 2n x 2n orthogonal matrix, using
    the optimal design introduced in arXiv:[].

    Args:
        qubits: Sequence of n qubits to apply the operations over. The qubits
                should be ordered in linear physical order.
        orthogonal_matrix: 2n x 2n orthogonal matrix defining the Gaussian transformation

    Returns:
        Sequence of Cirq gate operations
    """

    """Compute the decomposition of the orthogonal matrix into
    4 x 4 orthogonal block transformations, a diagonal matrix of signs,
    and one extra Givens rotation (in left_rotations)"""
    left_rotations, right_rotations, signs = majorana_block_decomposition(orthogonal_matrix)

    """Decompose each 4 x 4 transformation into a circuit
    of Givens rotations and a layer of Pauli gates by
    bootstrapping from the standard circuit design on
    only two qubits at a time"""
    for op in right_rotations:
        p, q, orth_mat = cast(Tuple[int, int, np.ndarray], op)
        yield standard_majorana_givens_circuit(qubits, orth_mat, p)

    """Implement the diagonal matrix of signs"""
    yield majorana_sign_gates(qubits, signs)

    """The extra Givens rotation from left_rotations"""
    p, q, theta = cast(Tuple[int, int, float], left_rotations[0])
    yield cirq.Z(qubits[p // 2])**(theta / np.pi)

    """Perform the left rotations"""
    for op in left_rotations[1:]:
        p, q, orth_mat = cast(Tuple[int, int, np.ndarray], op)
        yield standard_majorana_givens_circuit(qubits, orth_mat, p)


def optimal_gaussian_circuit_spin_block_diag(up_qubits: Sequence[cirq.Qid],
                                             down_qubits: Sequence[cirq.Qid],
                                             up_orthogonal_matrix: np.ndarray,
                                             down_orthogonal_matrix: np.ndarray,
                                             up_matrix_det=None,
                                             ) -> Iterable[cirq.Operation]:
    """
    Perform the Gaussian circuit to implement a block-diagonal
    Gaussian transformation across two spin sectors. Demands that
    the qubits of each spin flavor be physically grouped together.

    Args:
        up_qubits: Sequence of qubits corresponding to spin-up fermion modes.
        down_qubits: Sequence of qubits corresponding to spin-down fermion modes.
        up_orthogonal_matrix: 2n_up x 2n_up orthogonal matrix defining the
                Gaussian transformation on the spin-up sector
        down_orthogonal_matrix: 2n_down x 2n_down orthogonal matrix defining the
                Gaussian transformation on the spin-down sector
        up_matrix_det (Optional): The determinant of up_orthogonal_matrix, if it
                was precomputed. Default is None (code will compute it).

    Returns:
        Sequence of Cirq gate operations
    """

    """Construct independent Gaussian circuits on each spin sector"""
    yield optimal_gaussian_circuit(up_qubits, up_orthogonal_matrix)
    yield optimal_gaussian_circuit(down_qubits, down_orthogonal_matrix)

    """If det(Q_up) == -1, then we need to correct signs on the Majoranas
    on the spin-down chain. This convention is chosen such that this circuit
    is equivalent to the circuit generated by the block-diagonal matrix
    
    [Q_up, 0]
    [0, Q_down]
    
    up to a global phase factor. Alternatively we could just say that
    Q_down = -Q_down if det(Q_up) == -1, but then Q_up and Q_down are
    no longer independent variables.
    
    The user is given the option to enter the determinant of Q_up from
    a precalculation, to avoid having to compute the determinant here.
    This is useful when, for instance, Q_up is a permutation matrix, in
    which case it takes O(n^2) integer operations to calculate its
    determinant, as opposed to O(n^3) floating point operations."""
    if up_matrix_det is None:
        up_matrix_det = np.linalg.det(up_orthogonal_matrix)
    if up_matrix_det < 0.0:
        for qubit in down_qubits:
            yield cirq.Z(qubit)


def majorana_block_decomposition(orthogonal_matrix: np.ndarray
                                 ) -> Tuple[list, list, np.ndarray]:
    """
    Perform the decomposition of an orthogonal matrix

    Q = B_{R + L} ... B_{R + 1} G D B_R ... B_1,

    where each B_i is a 4 x 4 orthogonal transformation, G is a
    2 x 2 Givens rotation, and D is a diagonal matrix of {+1, -1} signs.
    This is bootstrapped from arXiv:1603.08788, replacing 2 x 2 Givens
    rotations with the 4 x 4 B's.

    Args:
        orthogonal_matrix: 2n x 2n orthogonal matrix to decompose

    Returns:
        left_rotations: Sequence of 4x4 transformations which act from
                the left to zero out Q, plus a final Givens rotation
        right_rotations: Sequence of 4x4 transformations which act from
                the right to zero out Q
        signs: 2n array of signs which define the diagonal matrix D
    """
    N = orthogonal_matrix.shape[0]
    if N % 2 == 1:
        raise ValueError('Input must be an orthogonal matrix with even dimension.')
    n_modes = N // 2

    current_matrix = np.copy(orthogonal_matrix)

    right_rotations = []
    left_rotations = []
    for i in range(1, n_modes):
        if i % 2 == 1:
            for j in range(i):
                """The starting row and column indices to extract the
                2 x 4 matrix A, whose left 2 x 2 block we wish to zero out"""
                row = 2 * (n_modes - j - 1)
                col = 2 * (i - j - 1)
                A = current_matrix[row:row + 2, col:col + 4]
                """QR decompose A such that we zero its left 2 x 2 block"""
                B = block_qr_decomposition(A)
                """Perform the orthogonal transformation B to zero out the
                desired block"""
                block_ortho_transform(current_matrix, B.T, col, col + 2, which='col')

                right_rotations.append((col, col + 2, B))

        else:
            """The same as with right_rotations above, except we extract a
            4 x 2 matrix and zero out its lower 2 x 2 block"""
            for j in range(1, i + 1):
                row = 2 * (n_modes + j - i - 2)
                col = 2 * (j - 1)
                A = current_matrix[row:row + 4, col:col + 2]
                B = block_qr_decomposition(A)
                block_ortho_transform(current_matrix, B.T, row, row + 2, which='row')

                left_rotations.append((row, row + 2, B))

    """Givens rotate the remaining 2 x 2 block on the diagonal. If n_modes is odd,
    then this block is at the bottom because the last step of the above loop
    zeroes out chunks of size 4 x 2. In other words, the nonzero upper-triangular
    2 x 2 block is pushed to the top, ensuring that all the 2 x 2 blocks along
    the diagonal are diagonal themselves, except for the lowermost 2 x 2 block
    which was untouched by that last loop (i.e., nothing was pushed into it). On
    the other hand, if n_modes is even, then the last step zeroes out 4 x 2 chunks,
    so now the uppermost 2 x 2 block was left untouched which needs to be Givens
    rotated."""
    if n_modes % 2 == 1:
        i = N - 2
    else:
        i = 0
    A = current_matrix[i:i + 2, i:i + 2]
    theta = np.arctan2(A[1, 0], A[0, 0])
    gmat = real_givens_matrix(theta)
    givens_rotate(current_matrix, gmat.T, i, i + 1, which='row')

    left_rotations.append((i, i + 1, theta))

    """Reverse the order of left_rotations to get the sequence 
    in the correct order (note that right-acting rotations are
    already in proper order)"""
    left_rotations.reverse()

    return left_rotations, right_rotations, np.diag(current_matrix)


def block_qr_decomposition(block_matrix: np.ndarray
                           ) -> np.ndarray:
    """


    Args:
        block_matrix: 4 x 2 or 2 x 4 array, whose left or lower 2 x 2 block
                we wish to zero out (and make the other block triangular)

    Returns:
        Q: 4 x 4 orthogonal matrix which zeroes out the block
    """
    if block_matrix.shape == (4, 2):
        """If 4 x 2, the normal QR decomposition suffices"""
        Q, _ = np.linalg.qr(block_matrix, mode='complete')

    elif block_matrix.shape == (2, 4):
        """If 2 x 4, we need to do an LQ decomposition and
        then reorganize blocks"""
        Q, _ = np.linalg.qr(block_matrix.T, mode='complete')
        Q = Q.T[[2, 3, 0, 1], :]

    else:
        raise ValueError('Input must be a 2 x 4 or 4 x 2 matrix.')

    return Q


def block_ortho_transform(operator: np.ndarray,
                          orthogonal_matrix: np.ndarray,
                          p: int,
                          q: int,
                          which='row'):
    """
    Performs the 4-dim orthogonal transformation on an input matrix of
    arbitrary size (at least 4x4) according to the rows/cols
    (p, p + 1, q, q + 1). Basically, does matrix multiplication but w/o
    needing to embed the orthogonal matrix into a bigger matrix.

    Args:
        operator: Larger matrix to be multiplied by orthogonal_matrix
        orthogonal_matrix: 4x4 orthogonal matrix to multiply operator by
        p: First pair of axes to rotate
        q: Second pair of axes to rotate
        which: If 'row', p and q denote rows which are rotated (i.e.,
                orthogonal_matrix @ operator). If 'col', then we rotate
                columns instead (operator @ orthogonal_matrix)

    Returns:
        Nothing (transforms in place)
    """

    if orthogonal_matrix.shape != (4, 4):
        raise ValueError('"orthogonal_matrix" must be 4 x 4.')

    if which == 'row':
        """Rotate rows p, p + 1, q, q + 1;
        Effects left multiplication by orthogonal_matrix"""
        rows_p = operator[p:p + 2].copy()
        rows_q = operator[q:q + 2].copy()
        rows = np.vstack((rows_p, rows_q))

        transformed_rows = orthogonal_matrix.dot(rows)
        operator[p:p + 2] = transformed_rows[0:2]
        operator[q:q + 2] = transformed_rows[2:4]

    elif which == 'col':
        """Rotate columns p, p + 1, q, q + 1;
        Effects right multiplication by orthogonal_matrix"""
        cols_p = operator[:, p:p + 2].copy()
        cols_q = operator[:, q:q + 2].copy()
        cols = np.hstack((cols_p, cols_q))

        transformed_cols = cols.dot(orthogonal_matrix)
        operator[:, p:p + 2] = transformed_cols[:, 0:2]
        operator[:, q:q + 2] = transformed_cols[:, 2:4]

    else:
        raise ValueError('"which" must be equal to "row" or "col".')

    return


def real_givens_matrix(theta: float
                       ) -> np.ndarray:
    """
    Constructs an SO(2) matrix

    [c, -s]
    [s, c]

    where c = cos(theta), s = sin(theta). Note that this rotates
    counter-clockwise by theta in the (i, j) axes, following the convention
    that the corresponding Pauli rotation of an observable A is

    exp(i (theta / 2) P) A exp(-i (theta / 2) P)

    Args:
        theta: Rotation angle (positive = counter-clockwise)

    Returns:
        gmat: Givens rotation matrix
    """
    c = np.cos(theta)
    s = np.sin(theta)
    gmat = np.array([[c, -s],
                     [s, c]])

    return gmat


def standard_givens_decomposition(orthogonal_matrix: np.ndarray
                                  ) -> Tuple[list, np.ndarray]:
    """
    Perform the decomposition of an orthogonal matrix

    Q = G_1 ... G_L D

    where G_i are real Givens rotations and D is a diagonal
    matrix of signs +1, -1. This is essentially the design of
    Reck et al., Phys. Rev. Lett. 73, 58 (1994), simplified
    for orthogonal matrices.

    Args:
        orthogonal_matrix: Orthogonal matrix to decompose

    Returns:
        rotations: Sequence of Givens rotations
        signs: array of signs defining the diagonal matrix D
    """
    N = orthogonal_matrix.shape[0]

    current_matrix = np.copy(orthogonal_matrix)

    rotations = []
    for j in range(N - 1):
        for i in range(N - 1, j, -1):
            theta = np.arctan2(current_matrix[i, j], current_matrix[i - 1, j])
            gmat = real_givens_matrix(theta)
            givens_rotate(current_matrix, gmat.T, i - 1, i, which='row')

            rotations.append((i - 1, i, theta))
    """Reverse the sequence to get the correct
    order for left-acting Givens rotations"""
    rotations.reverse()

    return rotations, np.diag(current_matrix)


def standard_majorana_givens_circuit(qubits: Sequence[cirq.Qid],
                                     orthogonal_matrix: np.ndarray,
                                     index_offset: int = 0
                                     ) -> Iterable[cirq.Operation]:
    """
    Constructs a Cirq circuit which implements the fermionic Gaussian
    unitary transformation given by the 2n x 2n orthogonal matrix, using
    the suboptimal Reck et al. design.

    Args:
        qubits: Sequence of n qubits to apply the operations over. The qubits
                should be ordered in linear physical order.
        orthogonal_matrix: 2n x 2n orthogonal matrix defining the Gaussian transformation
        index_offset (Optional): Offsets all qubit indices by some integer. Used for
                bootstrapping 4 x 4 blocks acting on different pairs of qubits.
                Default is 0.

    Returns:
        Sequence of Cirq gate operations
    """
    rotations, signs = standard_givens_decomposition(orthogonal_matrix)

    full_sign_diag = np.ones(2 * len(qubits))
    full_sign_diag[index_offset:index_offset + len(signs)] = signs
    yield majorana_sign_gates(qubits, full_sign_diag)

    for op in rotations:
        r, s, theta = cast(Tuple[int, int, float], op)
        yield majorana_rotation_gate(qubits, r + index_offset, s + index_offset, theta)


def majorana_rotation_gate(qubits: Sequence[cirq.Qid],
                           p: int, q: int,
                           theta: float
                           ) -> Iterable[cirq.Operation]:
    """
    Produces the (sequence of) Cirq gate(s) corresponding to the Majorana
    rotation

    exp(-theta/2 \gamma_p \gamma_q).

    If this doesn't map to a local two-qubit gate under the Jordan-Wigner
    transformation, then we raise an error.

    Args:
        qubits: Sequence of two qubits, for which mode p should refer
                to qubits[0] and mode q should refer to qubits[1]
        p, q: Majorana modes generating the rotation
        theta: Rotation angle

    Returns:
        Sequence of gate operations
    """
    if np.isclose(theta, 0.0):
        return

    if p > q:
        p, q = q, p
    d = q - p

    if d == 1:
        if p % 2 == 0:
            i = p // 2
            yield cirq.Z(qubits[i])**(theta / np.pi)
        else:
            i = (p - 1) // 2
            yield cirq.XXPowGate(exponent=theta / np.pi).on(qubits[i], qubits[i + 1])

    elif d == 2:
        if p % 2 == 0:
            i = p // 2
            yield cirq.Z(qubits[i])**(-0.5)
            yield cirq.XXPowGate(exponent=-theta / np.pi).on(qubits[i], qubits[i + 1])
            yield cirq.Z(qubits[i])**0.5
        else:
            i = (p - 1) // 2
            yield cirq.Z(qubits[i + 1])**(-0.5)
            yield cirq.XXPowGate(exponent=theta / np.pi).on(qubits[i], qubits[i + 1])
            yield cirq.Z(qubits[i + 1])**0.5

    elif d == 3 and p % 2 == 0:
        i = p // 2
        yield cirq.YYPowGate(exponent=-theta / np.pi).on(qubits[i], qubits[i + 1])

    else:
        raise ValueError('Majorana indices do not map onto 2-local gates.')


def majorana_sign_gates(qubits: Sequence[cirq.Qid],
                        signs: Iterable
                        ) -> Iterable[cirq.Operation]:
    """
    Implements the matchgate/Gaussian transformation by a diagonal
    matrix of signs D = np.diag(signs). Specifically,

    \gamma_i = D_{ii} * \gamma_i.

    Args:
        qubits: Sequence of qubits
        signs: linear array of +1, -1 signs

    Returns:
        Sequence of gate operations
    """
    """Round signs just in case - if signs are not +/-1 then this
    transformation is not unitary"""
    signs = np.sign(signs)

    N = len(signs)
    n_modes = N // 2

    pauli_tableau = np.zeros(N, dtype=int)
    for p in range(n_modes):
        if signs[2 * p] == signs[2 * p + 1]:
            if signs[2 * p] == -1.0:
                pauli_tableau[p + n_modes] += 1
        else:
            pauli_tableau[p] += 1
            if signs[2 * p] == 1.0:
                for q in range(p + 1, n_modes):
                    pauli_tableau[q + n_modes] += 1
            else:
                for q in range(p, n_modes):
                    pauli_tableau[q + n_modes] += 1

    pauli_tableau %= 2

    for p in range(n_modes):
        pauli = (pauli_tableau[p], pauli_tableau[p + n_modes])
        if pauli == (0, 1):
            yield cirq.Z(qubits[p])
        elif pauli == (1, 0):
            yield cirq.X(qubits[p])
        elif pauli == (1, 1):
            yield cirq.Y(qubits[p])


def embed_unitary_into_orthogonal_matrix(unitary: np.ndarray
                                         ) -> np.ndarray:
    """
    Helper function which implements the embedding of U(n) -> SO(2n)
    by the Gaussian transformation (representation). We take the
    convention that

    optimal_givens_decomposition(qubits, unitary) = optimal_matchgate_circuit(qubits, orthogonal_matrix)

    where `optimal_givens_decomposition` is contained in the OpenFermion
    library (https://github.com/quantumlib/OpenFermion). Specifically,

    u -> Q = [R_{ij}]_{i,j = 0}^{n - 1},

    R_{ij} = [Re, -Im]
             [Im, Re],

    Re = u[i, j].real, Im = u[i, j].imag.

    Equivalently, the Gaussian circuit U_Q satisfies

    U_Q^\dagger a_i U_Q = \sum_{j = 0}^{n - 1} u[i, j] a_j

    where a_i are the annihilation operators.

    Args:
        unitary: n x n unitary matrix

    Returns:
        orthogonal_matrix: 2n x 2n orthogonal matrix
    """
    n_orbitals = unitary.shape[0]

    orthogonal_matrix = np.zeros((2 * n_orbitals, 2 * n_orbitals))

    for p in range(n_orbitals):
        real_part = unitary[p, p].real
        imag_part = unitary[p, p].imag
        orthogonal_matrix[2 * p:2 * p + 2, 2 * p:2 * p + 2] = np.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
        )

    for p, q in combinations(range(n_orbitals), 2):
        real_part = unitary[p, q].real
        imag_part = unitary[p, q].imag
        orthogonal_matrix[2 * p:2 * p + 2, 2 * q:2 * q + 2] = np.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
        )

        real_part = unitary[q, p].real
        imag_part = unitary[q, p].imag
        orthogonal_matrix[2 * q:2 * q + 2, 2 * p:2 * p + 2] = np.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
        )

    return orthogonal_matrix
