# -*- coding: utf-8 -*-

"""
The code here allows for compiling Cirq circuits of general fermionic
Gaussian unitaries, using their O(2n)-matrix representation.

Adapted from OpenFermion's optimal_givens_decomposition to the context of
general Gaussian transformations. Assumes Jordan-Wigner mapping; specifically,
for p \in {0, ..., n-1},

\gamma_{2p} = a_p + a_p^\dagger = X_p \prod_{q < p} Z_q,
\gamma_{2p+1} = -i(a_p - a_p^\dagger) = Y_p \prod_{q < p} Z_q.

The routine here simplifies the general fermionic Gaussian unitary
construction of Phys. Rev. Appl. 9, 044036 (2018), namely by implementing any
O(2n) transformation, rather than requiring additional circuitry on top of
the state-preparation algorithm.
"""

"""
Note from OpenFermion:
A routine for constructing a circuit to exactly implement a unitary generated by
one-body rotations through the optimal Givens rotation network.  Construction
of this circuit can be found in Optica Vol. 3, Issue 12, pp. 1460-1465 (2016).
This Givens network improves upon the parallel Givens network for implementing
basis rotations in Phys. Rev. Lett. 120, 110501 (2018).
"""
from typing import cast, Iterable, Sequence, Tuple

import numpy
import cirq
import itertools

from openfermion.linalg import givens_matrix_elements, givens_rotate


class GivensTranspositionError(Exception):
    pass


class GivensMatrixError(Exception):
    pass


def gaussian_givens_decomposition(qubits: Sequence[cirq.Qid],
                                  orthogonal_matrix: numpy.ndarray
                                  ) -> Iterable[cirq.Operation]:
    r"""
    Implement a circuit that provides the unitary that is generated by
    quadratic fermion generators
    .. math::
        U(Q) = exp(-(1/4) [log(Q)]_{j,k} \gamma_j \gamma_k).
    This can be used for implementing an exact fermionic Gaussian unitary from
    any orthogonal 2n x 2n matrix Q.
    Args:
        qubits: Sequence of qubits to apply the operations over.  The qubits
                should be ordered in linear physical order.
        orthogonal_matrix: 2n x 2n orthogonal matrix which defines the linear
                           transformation,
    .. math::
        U(Q)^\dagger \gamma_j U(Q) = \sum_{k=0}^{2n-1} Q_{j,k} \gamma_k.
    """
    N = orthogonal_matrix.shape[0]
    assert N % 2 == 0
    
    current_matrix = numpy.copy(orthogonal_matrix)
    right_rotations = []
    left_rotations = []
    for i in range(1, N):
        if i % 2 == 1:
            for j in range(0, i):
                # eliminate U[N - j, i - j] by mixing U[N - j, i - j],
                # U[N - j, i - j - 1] by right multiplication
                # of a givens rotation matrix in column [i - j, i - j + 1]
                gmat = givens_matrix_elements(current_matrix[N - j - 1,
                                                             i - j - 1],
                                              current_matrix[N - j - 1,
                                                             i - j - 1 + 1],
                                              which='left')
                right_rotations.append((gmat.T, (i - j - 1, i - j)))
                givens_rotate(current_matrix,
                              gmat.conj(),
                              i - j - 1,
                              i - j,
                              which='col')
        else:
            for j in range(1, i + 1):
                # elimination of U[N + j - i, j] by mixing U[N + j - i, j] and
                # U[N + j - i - 1, j] by left multiplication
                # of a givens rotation that rotates row space
                # [N + j - i - 1, N + j - i
                gmat = givens_matrix_elements(current_matrix[N + j - i - 1 - 1,
                                                             j - 1],
                                              current_matrix[N + j - i - 1,
                                                             j - 1],
                                              which='right')
                left_rotations.append((gmat, (N + j - i - 2, N + j - i - 1)))
                givens_rotate(current_matrix,
                              gmat,
                              N + j - i - 2,
                              N + j - i - 1,
                              which='row')

    new_left_rotations = []
    for (left_gmat, (i, j)) in reversed(left_rotations):
        phase_matrix = numpy.diag([current_matrix[i, i], current_matrix[j, j]])
        matrix_to_decompose = left_gmat.conj().T.dot(phase_matrix)
        new_givens_matrix = givens_matrix_elements(matrix_to_decompose[1, 0],
                                                   matrix_to_decompose[1, 1],
                                                   which='left')
        new_phase_matrix = matrix_to_decompose.dot(new_givens_matrix.T)

        # check if T_{m,n}^{-1}D  = D T.
        # coverage: ignore
        if not numpy.allclose(new_phase_matrix.dot(new_givens_matrix.conj()),
                              matrix_to_decompose):
            raise GivensTranspositionError("Failed to shift the phase matrix "
                                           "from right to left")
        # coverage: ignore

        current_matrix[i, i], current_matrix[j, j] = (new_phase_matrix[0, 0],
                                                      new_phase_matrix[1, 1])
        new_left_rotations.append((new_givens_matrix.conj(), (i, j)))

    phases = numpy.diag(current_matrix)
    rotations = []
    ordered_rotations = []
    for (gmat, (i, j)) in list(reversed(new_left_rotations)) + list(
            map(lambda x: (x[0].conj().T, x[1]), reversed(right_rotations))):
        ordered_rotations.append((gmat, (i, j)))
        
        """Commented out because orthogonal matrices must be real, so this
        "impossible" happening is impossibly impossible.
        
        # if this throws the impossible has happened
        # coverage: ignore
        if not numpy.isclose(gmat[0, 0].imag, 0.0):
            raise GivensMatrixError(
                "Givens matrix does not obey our convention that all elements "
                "in the first column are real")
        if not numpy.isclose(gmat[1, 0].imag, 0.0):
            raise GivensMatrixError(
                "Givens matrix does not obey our convention that all elements "
                "in the first column are real")
        # coverage: ignore
        """
        
        theta = numpy.arcsin(numpy.real(gmat[1, 0]))
        rotations.append((i, j, theta))
    
    for op in reversed(rotations):
        i, j, theta = cast(Tuple[int, int, float], op)
        if not numpy.isclose(theta, 0.0):
            if i % 2 == 0:
                yield cirq.Z(qubits[i // 2])**(theta/numpy.pi)
            else:
                p = (i - 1) // 2
                yield cirq.ops.XXPowGate(exponent=theta/numpy.pi).on(
                    qubits[p], qubits[p + 1])
    
    # final layer of Pauli gates to implement phases, which must be \pm 1 since
    # orthogonal matrices are real
    # we use the F_2n/stabilizer representation of Pauli operators here
    final_pauli_gate = numpy.zeros(N)
    n = N // 2
    for p in range(n):
        if numpy.isclose(phases[2*p], phases[2*p + 1]):
            if numpy.isclose(phases[2*p], -1.0):
                final_pauli_gate[p + n] += 1
        else:
            final_pauli_gate[p] += 1
            if numpy.isclose(phases[2*p], 1.0):
                for q in range(p + 1, n):
                    final_pauli_gate[q + n] += 1
            else:
                for q in range(p, n):
                    final_pauli_gate[q + n] += 1
    
    for p in range(n):
        if final_pauli_gate[p] % 2 == 0 and final_pauli_gate[p + n] % 2 == 1:
            yield cirq.Z(qubits[p])
        elif final_pauli_gate[p] % 2 == 1 and final_pauli_gate[p + n] % 2 == 0:
            yield cirq.X(qubits[p])
        elif final_pauli_gate[p] % 2 == 1 and final_pauli_gate[p + n] % 2 == 1:
            yield cirq.Y(qubits[p])

def permutation_to_matrix(permutation):
    """
    Converts a permutation (a list or tuple of ints containing all elements of
    {1, ..., N}) to its faithful N x N matrix representation. The convention
    for matrix multiplication is
    
    Q @ e_i = e_{\pi(i)},
    
    where e_i is the standard basis vector with 1 in the ith entry, and \pi is
    the permutation so that \pi(i) = permutation[i].
    """
    N = len(permutation)
    Q = numpy.eye(N, dtype=int)
    
    return Q[:, permutation]

def embed_unitary_into_orthogonal(unitary: numpy.ndarray) -> numpy.ndarray:
    """
    Since the O(2n) transformation of Majorana modes is a generalization of the
    particle-number-conserving U(n) transformation (basis rotations), one may
    embed the U(n) matrix into an O(2n) matrix. This allows concatenation of
    general Gaussian unitaries with number-conserving Gaussian unitaries using
    the group homomorphism property of the O(2n) fermion representation,
    
    U(Q) U(R) = U(QR).
    
    This embedding is just the canonical embedding of U(1) -> SO(2), up to a
    sign convention.
    """
    n = unitary.shape[0]
    
    embedded_orthogonal_matrix = numpy.zeros((2*n, 2*n))
    
    for p in range(n):
        real_part = unitary[p, p].real
        imag_part = unitary[p, p].imag
        embedded_orthogonal_matrix[2*p:2*p + 2, 2*p:2*p + 2] = numpy.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
            )
    
    for p, q in itertools.combinations(range(n), 2):
        real_part = unitary[p, q].real
        imag_part = unitary[p, q].imag
        embedded_orthogonal_matrix[2*p:2*p + 2, 2*q:2*q + 2] = numpy.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
            )
        
        real_part = unitary[q, p].real
        imag_part = unitary[q, p].imag
        embedded_orthogonal_matrix[2*q:2*q + 2, 2*p:2*p + 2] = numpy.array(
            [[real_part, -imag_part],
             [imag_part, real_part]]
            )
    
    return embedded_orthogonal_matrix
